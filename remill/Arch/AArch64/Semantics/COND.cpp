/*
 * Copyright (c) 2017 Trail of Bits, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


namespace {

template <bool (*check_cond)(const State &), typename D,
          typename S1, typename S2>
DEF_SEM(CSEL, D dst, S1 src1, S2 src2) {
  auto val = check_cond(state) ? Read(src1) : Read(src2);
  WriteZExt(dst, val);
  return memory;
}
}  // namespace

DEF_ISEL(CSEL_32_CONDSEL_GE) = CSEL<CondGE, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_GT) = CSEL<CondGT, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_LE) = CSEL<CondLE, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_LT) = CSEL<CondLT, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_EQ) = CSEL<CondEQ, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_NE) = CSEL<CondNE, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_CS) = CSEL<CondCS, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_CC) = CSEL<CondCC, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_MI) = CSEL<CondMI, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_PL) = CSEL<CondPL, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_VS) = CSEL<CondVS, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_VC) = CSEL<CondVC, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_HI) = CSEL<CondHI, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_LS) = CSEL<CondLS, R32W, R32, R32>;
DEF_ISEL(CSEL_32_CONDSEL_AL) = CSEL<CondAL, R32W, R32, R32>;

DEF_ISEL(CSEL_64_CONDSEL_GE) = CSEL<CondGE, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_GT) = CSEL<CondGT, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_LE) = CSEL<CondLE, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_LT) = CSEL<CondLT, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_EQ) = CSEL<CondEQ, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_NE) = CSEL<CondNE, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_CS) = CSEL<CondCS, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_CC) = CSEL<CondCC, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_MI) = CSEL<CondMI, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_PL) = CSEL<CondPL, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_VS) = CSEL<CondVS, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_VC) = CSEL<CondVC, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_HI) = CSEL<CondHI, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_LS) = CSEL<CondLS, R64W, R64, R64>;
DEF_ISEL(CSEL_64_CONDSEL_AL) = CSEL<CondAL, R64W, R64, R64>;

namespace {

template <bool (*check_cond)(const State &), typename D,
          typename S1, typename S2>
DEF_SEM(CSNEG, D dst, S1 src1, S2 src2) {
  WriteZExt(dst, Select(check_cond(state),
                        Read(src1),
                        UAdd(UNot(Read(src2)), ZExtTo<S2>(1))));
  return memory;
}

}  // namespace

DEF_ISEL(CSNEG_32_CONDSEL_GE) = CSNEG<CondGE, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_GT) = CSNEG<CondGT, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_LE) = CSNEG<CondLE, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_LT) = CSNEG<CondLT, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_EQ) = CSNEG<CondEQ, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_NE) = CSNEG<CondNE, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_CS) = CSNEG<CondCS, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_CC) = CSNEG<CondCC, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_MI) = CSNEG<CondMI, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_PL) = CSNEG<CondPL, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_VS) = CSNEG<CondVS, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_VC) = CSNEG<CondVC, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_HI) = CSNEG<CondHI, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_LS) = CSNEG<CondLS, R32W, R32, R32>;
DEF_ISEL(CSNEG_32_CONDSEL_AL) = CSNEG<CondAL, R32W, R32, R32>;

DEF_ISEL(CSNEG_64_CONDSEL_GE) = CSNEG<CondGE, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_GT) = CSNEG<CondGT, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_LE) = CSNEG<CondLE, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_LT) = CSNEG<CondLT, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_EQ) = CSNEG<CondEQ, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_NE) = CSNEG<CondNE, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_CS) = CSNEG<CondCS, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_CC) = CSNEG<CondCC, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_MI) = CSNEG<CondMI, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_PL) = CSNEG<CondPL, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_VS) = CSNEG<CondVS, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_VC) = CSNEG<CondVC, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_HI) = CSNEG<CondHI, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_LS) = CSNEG<CondLS, R64W, R64, R64>;
DEF_ISEL(CSNEG_64_CONDSEL_AL) = CSNEG<CondAL, R64W, R64, R64>;

namespace {

template <bool (*check_cond)(const State &), typename D,
          typename S1, typename S2>
DEF_SEM(CSINC, D dst, S1 src1, S2 src2)  {
  WriteZExt(dst, Select(check_cond(state), Read(src1), UAdd(Read(src2), 1)));
  return memory;
}
}  // namespace

DEF_ISEL(CSINC_32_CONDSEL_GE) = CSINC<CondGE, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_GT) = CSINC<CondGT, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_LE) = CSINC<CondLE, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_LT) = CSINC<CondLT, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_EQ) = CSINC<CondEQ, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_NE) = CSINC<CondNE, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_CS) = CSINC<CondCS, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_CC) = CSINC<CondCC, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_MI) = CSINC<CondMI, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_PL) = CSINC<CondPL, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_VS) = CSINC<CondVS, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_VC) = CSINC<CondVC, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_HI) = CSINC<CondHI, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_LS) = CSINC<CondLS, R32W, R32, R32>;
DEF_ISEL(CSINC_32_CONDSEL_AL) = CSINC<CondAL, R32W, R32, R32>;

DEF_ISEL(CSINC_64_CONDSEL_GE) = CSINC<CondGE, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_GT) = CSINC<CondGT, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_LE) = CSINC<CondLE, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_LT) = CSINC<CondLT, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_EQ) = CSINC<CondEQ, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_NE) = CSINC<CondNE, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_CS) = CSINC<CondCS, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_CC) = CSINC<CondCC, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_MI) = CSINC<CondMI, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_PL) = CSINC<CondPL, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_VS) = CSINC<CondVS, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_VC) = CSINC<CondVC, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_HI) = CSINC<CondHI, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_LS) = CSINC<CondLS, R64W, R64, R64>;
DEF_ISEL(CSINC_64_CONDSEL_AL) = CSINC<CondAL, R64W, R64, R64>;


namespace {

template <bool (*check_cond)(const State &), typename D,
          typename S1, typename S2>
DEF_SEM(CSINV, D dst, S1 src1, S2 src2)  {
  WriteZExt(dst, Select(check_cond(state), Read(src1), UNot(Read(src2))));
  return memory;
}
}  // namespace

DEF_ISEL(CSINV_32_CONDSEL_GE) = CSINV<CondGE, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_GT) = CSINV<CondGT, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_LE) = CSINV<CondLE, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_LT) = CSINV<CondLT, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_EQ) = CSINV<CondEQ, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_NE) = CSINV<CondNE, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_CS) = CSINV<CondCS, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_CC) = CSINV<CondCC, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_MI) = CSINV<CondMI, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_PL) = CSINV<CondPL, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_VS) = CSINV<CondVS, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_VC) = CSINV<CondVC, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_HI) = CSINV<CondHI, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_LS) = CSINV<CondLS, R32W, R32, R32>;
DEF_ISEL(CSINV_32_CONDSEL_AL) = CSINV<CondAL, R32W, R32, R32>;

DEF_ISEL(CSINV_64_CONDSEL_GE) = CSINV<CondGE, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_GT) = CSINV<CondGT, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_LE) = CSINV<CondLE, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_LT) = CSINV<CondLT, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_EQ) = CSINV<CondEQ, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_NE) = CSINV<CondNE, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_CS) = CSINV<CondCS, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_CC) = CSINV<CondCC, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_MI) = CSINV<CondMI, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_PL) = CSINV<CondPL, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_VS) = CSINV<CondVS, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_VC) = CSINV<CondVC, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_HI) = CSINV<CondHI, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_LS) = CSINV<CondLS, R64W, R64, R64>;
DEF_ISEL(CSINV_64_CONDSEL_AL) = CSINV<CondAL, R64W, R64, R64>;

namespace {
template <bool (*check_cond)(const State &), typename S1, typename S2>
DEF_SEM(CCMP, S1 src1, S2 src2, S2 nzcv) {
  using T = typename BaseType<S1>::BT;
  if (check_cond(state)) {
    (void) AddWithCarryNZCV(state, Read(src1), UNot(Read(src2)), T(1));
  } else {
    auto nzcv_val = Read(nzcv);
    FLAG_V = UCmpNeq(UAnd(nzcv_val, T(1)), T(0));
    FLAG_C = UCmpNeq(UAnd(nzcv_val, T(2)), T(0));
    FLAG_Z = UCmpNeq(UAnd(nzcv_val, T(4)), T(0));
    FLAG_N = UCmpNeq(UAnd(nzcv_val, T(8)), T(0));
  }
  return memory;
}
}  // namespace

DEF_ISEL(CCMP_32_CONDCMP_IMM_EQ) = CCMP<CondEQ, R32, I32>;
